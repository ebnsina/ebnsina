const whatsNewInReact19 = "---\ntitle: What's new in React 19\ndate: '2024-03-15'\ntags: ['react']\nexcerpt: What's new in React 19\n---\n\n## Actions\n\nA common use case in React apps is to perform a data mutation and then update state in response. For example, when a user submits a form to change their name, you will make an API request, and then handle the response. In the past, you would need to handle pending states, errors, optimistic updates, and sequential requests manually.\n\nFor example, you could handle the pending and error state in useState:\n\n```jsx\n// Before Actions\nfunction UpdateName({}) {\n	const [name, setName] = useState('');\n	const [error, setError] = useState(null);\n	const [isPending, setIsPending] = useState(false);\n\n	const handleSubmit = async () => {\n		setIsPending(true);\n		const error = await updateName(name);\n		setIsPending(false);\n		if (error) {\n			setError(error);\n			return;\n		}\n		redirect('/path');\n	};\n\n	return (\n		<div>\n			<input value={name} onChange={(event) => setName(event.target.value)} />\n			<button onClick={handleSubmit} disabled={isPending}>\n				Update\n			</button>\n			{error && <p>{error}</p>}\n		</div>\n	);\n}\n```\n\nIn React 19, we’re adding support for using async functions in transitions to handle pending states, errors, forms, and optimistic updates automatically.\n\nFor example, you can use useTransition to handle the pending state for you:\n\n```jsx\n// Using pending state from Actions\nfunction UpdateName({}) {\n	const [name, setName] = useState('');\n	const [error, setError] = useState(null);\n	const [isPending, startTransition] = useTransition();\n\n	const handleSubmit = () => {\n		startTransition(async () => {\n			const error = await updateName(name);\n			if (error) {\n				setError(error);\n				return;\n			}\n			redirect('/path');\n		});\n	};\n\n	return (\n		<div>\n			<input value={name} onChange={(event) => setName(event.target.value)} />\n			<button onClick={handleSubmit} disabled={isPending}>\n				Update\n			</button>\n			{error && <p>{error}</p>}\n		</div>\n	);\n}\n```\n\nThe async transition will immediately set the isPending state to true, make the async request(s), and switch isPending to false after any transitions. This allows you to keep the current UI responsive and interactive while the data is changing.\n\n### Note\n\nBy convention, functions that use async transitions are called “Actions”.\nActions automatically manage submitting data for you:\n\n- Pending state: Actions provide a pending state that starts at the beginning of a request and automatically resets when the final state update is committed.\n- Optimistic updates: Actions support the new useOptimistic hook so you can show users instant feedback while the requests are submitting.\n- Error handling: Actions provide error handling so you can display Error Boundaries when a request fails, and revert optimistic updates to their original value automatically.\n- Forms: <form> elements now support passing functions to the action and formAction props. Passing functions to the action props use Actions by default and reset the form automatically after submission.\n\nBuilding on top of Actions, React 19 introduces useOptimistic to manage optimistic updates, and a new hook React.useActionState to handle common cases for Actions. In react-dom we’re adding <form> Actions to manage forms automatically and useFormStatus to support the common cases for Actions in forms.\n\nIn React 19, the above example can be simplified to:\n\n```jsx\n// Using <form> Actions and useActionState\nfunction ChangeName({ name, setName }) {\n	const [error, submitAction, isPending] = useActionState(async (previousState, formData) => {\n		const error = await updateName(formData.get('name'));\n		if (error) {\n			return error;\n		}\n		redirect('/path');\n		return null;\n	}, null);\n\n	return (\n		<form action={submitAction}>\n			<input type=\"text\" name=\"name\" />\n			<button type=\"submit\" disabled={isPending}>\n				Update\n			</button>\n			{error && <p>{error}</p>}\n		</form>\n	);\n}\n```\n\nn the next section, we’ll break down each of the new Action features in React 19.\n\nNew hook: useActionState\nTo make the common cases easier for Actions, we’ve added a new hook called useActionState:\n\n```jsx\nconst [error, submitAction, isPending] = useActionState(async (previousState, newName) => {\n	const error = await updateName(newName);\n	if (error) {\n		// You can return any result of the action.\n		// Here, we return only the error.\n		return error;\n	}\n\n	// handle success\n	return null;\n}, null);\n```\n\nuseActionState accepts a function (the “Action”), and returns a wrapped Action to call. This works because Actions compose. When the wrapped Action is called, useActionState will return the last result of the Action as data, and the pending state of the Action as pending.\n\n## React DOM: <form> Actions\n\nActions are also integrated with React 19’s new <form> features for react-dom. We’ve added support for passing functions as the action and formAction props of <form>, <input>, and <button> elements to automatically submit forms with Actions:\n\n```jsx\n<form action={actionFunction}></form>\n```\n\n[Learn more](https://react.dev/blog/2024/04/25/react-19)\n";
export {
  whatsNewInReact19 as default
};
